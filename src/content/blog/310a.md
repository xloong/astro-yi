---
title: CMD下的网络安全配置[zz]
description: 自带的关于网络的命令行工具很多，比如大家熟悉的ping,tracert,ipconfig,telnet,ftp,tftp,netstat，还有不太熟悉的nbtstat,pathping,nslookup,finger,route,netsh......这些命令又可分成三类：网络检测（如ping）、网络连接（如telnet）和网络配置（如netsh）。前面两种相对简单，本文只介绍两个网络配置工具。
date: 2007-12-30 04:30:39
category: 技术文章
tags: ['技术类', '安全', '脚本Script']
post_id: 310
alias:
ViewNums: 10552
---

信息来源：网络

自带的关于网络的**CMD**命令行工具很多，比如大家熟悉的ping,tracert,ipconfig,telnet,ftp,tftp,netstat，还有不太熟悉的nbtstat,pathping,nslookup,finger,route,netsh......
这些**CMD命令**又可分成三类：网络检测（如ping）、网络连接（如telnet）和网络配置（如netsh）。前面两种相对简单，本文只介绍两个网络配置工具。

netsh
在远程shell中使用netsh首先要解决一个交互方式的问题。前面说过，很多shell不能再次重定向输出输出，所以不能在这种环境下交互地使用ftp等命令行工具。解决的办法是，一般交互式的工具都允许使用脚本（或者叫应答文件）。比如ftp -s:filename。netsh也是这样：netsh -f filename。

netsh命令的功能非常多，可以配置IAS、DHCP、RAS、WINS、NAT服务器，TCP/IP协议，IPX协议，路由等。我们不是管理员，一般没必要了解这么多，只需用netsh来了解目标主机的网络配置信息。

1，TCP/IP配置

echo interface ip >s
echo show config >>s
netsh -f s
del s

由此你可以了解该主机有多个网卡和IP，是否是动态分配IP(DHCP)，内网IP是多少（如果有的话）。
这个命令和ipconfig /all差不多。

注意，以下命令需要目标主机启动remoteaccess服务。如果它被禁用，请先通过导入注册表解禁，然后
net start remoteaccess

2，ARP

echo interface ip >s
echo show ipnet >>s
netsh -f s
del s

这个比arp -a命令多一点信息。

3，TCP/UDP连接

echo interface ip >s
echo show tcpconn >>s
echo show udpconn >>s
netsh -f s
del s

这组命令和netstat -an一样。

4，网卡信息
如果netsh命令都有其他命令可代替，那它还有什么存在的必要呢？下面这个就找不到代替的了。

echo interface ip >s
echo show interface >>s
netsh -f s
del s

netsh的其他功能，比如修改IP，一般没有必要使用（万一改了IP后连不上，就"叫天不应叫地不灵"了），所以全部略过。

IPSec
首先需要指出的是，IPSec和TCP/IP筛选是不同的东西，大家不要混淆了。TCP/IP筛选的功能十分有限，远不如IPSec灵活和强大。下面就说说如何在命令行下控制IPSec。

XP系统用ipseccmd，2000下用ipsecpol。遗憾的是，它们都不是系统自带的。ipseccmd在xp系统安装盘的SUPPORTTOOLSSUPPORT.CAB中，ipsecpol在2000 Resource Kit里。而且，要使用ipsecpol还必须带上另外两个文件：ipsecutil.dll和text2pol.dll。三个文件一共119KB。

IPSec可以通过组策略来控制，但我找遍MSDN，也没有找到相应的安全模板的语法。已经配置好的IPSec策略也不能被导出为模板。所以，组策略这条路走不通。IPSec的设置保存在注册表中(HKEY_LOCAL_MACHINESOFTWAREPoliciesMicrosoftWindowsIPSecPolicyLocal)，理论上可以通过修改注册表来配置IPSec。但很多信息以二进制形式存放，读取和修改都很困难。相比之下，上传命令行工具更方便。

关于ipsecpol和ipseccmd的资料，网上可以找到很多，因此本文就不细说了，只是列举一些实用的例子。
在设置IPSec策略方面，ipseccmd命令的语法和ipsecpol几乎完全一样，所以只以ipsecpol为例：

1，防御rpc-dcom攻击

ipsecpol -p myfirewall -r rpc-dcom -f *+0:135:tcp *+0:135:udp *+0:137:udp *+0:138:udp *+0:139:tcp *+0:445:tcp *+0:445:udp -n BLOCK -w reg -x

这条命令关闭了本地主机的TCP135,139,445和udp135,137,138,445端口。
具体含义如下：
-p myfirewall 指定策略名为myfirewall
-r rpc-dcom 指定规则名为rpc-dcom
-f ...... 建立7个筛选器。*表示任何地址(源)；0表示本机地址(目标)；+表示镜像(双向)筛选。详细语法见ipsecpol -?
-n BLOCK 指定筛选操作是"阻塞"。注意，BLOCK必须是大写。
-w reg 将配置写入注册表，重启后仍有效。
-x 立刻激活该策略。

2，防止被ping

ipsecpol -p myfirewall -r antiping -f *+0::icmp -n BLOCK -w reg -x

如果名为myfirewall的策略已存在，则antiping规则将添加至其中。
注意，该规则同时也阻止了该主机ping别人。

3，对后门进行IP限制
假设你在某主机上安装了DameWare Mini Remote Control。为了保护它不被别人暴破密码或溢出，应该限制对其服务端口6129的访问。

ipsecpol -p myfw -r dwmrc_block_all -f *+0:6129:tcp -n BLOCK -w reg
ipsecpol -p myfw -r dwmrc_pass_me -f 123.45.67.89+0:6129:tcp -n PASS -w reg -x

这样就只有123.45.67.89可以访问该主机的6129端口了。
如果你是动态IP，应该根据IP分配的范围设置规则。比如：

ipsecpol -p myfw -r dwmrc_block_all -f *+0:6129:tcp -n BLOCK -w reg
ipsecpol -p myfw -r dwmrc_pass_me -f 123.45.67.*+0:6129:tcp -n PASS -w reg -x

这样就允许123.45.67.1至123.45.67.254的IP访问6129端口。

在写规则的时候，应该特别小心，不要把自己也阻塞了。如果你不确定某个规则的效果是否和预想的一样，可以先用计划任务"留下后路"。例如：

c:>net start schedule
Task Scheduler 服务正在启动 ..
Task Scheduler 服务已经启动成功。

c:>time /t
12:34

c:>at 12:39 ipsecpol -p myfw -y -w reg
新加了一项作业，其作业 ID = 1

然后，你有5分钟时间设置一个myfw策略并测试它。5分钟后计划任务将停止该策略。
如果测试结果不理想，就删除该策略。

c:>ipsecpol -p myfw -o -w reg

注意，删除策略前必须先确保它已停止。不停止它的话，即使删除也会在一段时间内继续生效。持续时间取决于策略的刷新时间，默认是180分钟。

如果测试通过，那么就启用它。

c:>ipsecpol -p myfw -x -w reg

最后说一下查看IPSec策略的办法。
对于XP很简单，一条命令搞定--ipseccmd show filters
而ipsecpol没有查询的功能。需要再用一个命令行工具netdiag。它位于2000系统安装盘的SUPPORTTOOLSSUPPORT.CAB中。（已经上传了三个文件，也就不在乎多一个了。^_^）

netdiag需要RemoteRegistry服务的支持。所以先启动该服务：

net start remoteregistry

不启动RemoteRegistry就会得到一个错误：

[FATAL] Failed to get system information of this machine.

netdiag这个工具功能十分强大，与网络有关的信息都可以获取！不过，输出的信息有时过于详细，超过命令行控制台cmd.exe的输出缓存，而不是每个远程cmd shell都可以用more命令来分页的。

查看ipsec策略的命令是：
netdiag /debug /test:ipsec

然后是一长串输出信息。IPSec策略位于最后。

软件安装
一个软件/工具的安装过程，一般来说只是做两件事：拷贝文件到特定目录和修改注册表。只要搞清楚具体的内容，那么就可以自己在命令行下实现了。（不考虑安装后需要注册激活等情况）

WinPcap是个很常用的工具，但必须在窗口界面下安装。在网上也可以找到不用GUI的版本（但还是有版权页），其实我们完全可以自己做一个。

以WinPcap 3.0a 为例。通过比较安装前后的文件系统和注册表快照，很容易了解整个安装过程。
除去反安装的部分，关键的文件有三个：wpcap.dll，packet.dll和npf.sys。前面两个文件位于system32目录下，第三个在system32drivers下。而注册表的变化是增加了一个系统服务NPF。注意，是系统服务（即驱动）不是Win32服务。

作为系统服务，不但要在HKEY_LOCAL_MACHINESYSTEMCurrentControlSetServices下增加主键，在HKEY_LOCAL_MACHINESYSTEMCurrentControlSetEnumRoot下也增加主键。而后者默认只有SYSTEM身份才可以修改。幸运的是，并不需要手动添加它，winpcap被调用时会自动搞定。甚至完全不用手动修改注册表，所有的事winpcap都会自己完成，只需要将三个文件复制到合适的位置就行了。

作为范例，还是演示一下如何修改注册表：利用前面说过的inf文件来实现。

[Version]
Signature="$WINDOWS NT$"
[DefaultInstall.Services]
AddService=NPF,,winpcap_svr
[winpcap_svr]
DisplayName=Netgroup Packet Filter
ServiceType=0x1
StartType=3
ErrorControl=1
ServiceBinary=%12%
pf.sys

将上面这些内容保存为_wpcap_.inf文件。
再写一个批处理_wpcap_.bat：

rundll32.exe setupapi,InstallHinfSection DefaultInstall 128 %CD%\_wpcap_.inf
del _wpcap_.inf
if /i %CD%==%SYSTEMROOT%system32 goto COPYDRV
copy packet.dll %SYSTEMROOT%system32
copy wpcap.dll %SYSTEMROOT%system32
del packet.dll
del wpcap.dll
:COPYDRV
if /i %CD%==%SYSTEMROOT%system32drivers goto END
copy npf.sys %SYSTEMROOT%system32drivers
del npf.sys
:END
del %0

然后用winrar将所有文件（5个）打包为自解压的exe，并将『高级自解压选项』->『解压后运行』设置为_wpcap_.bat，命令行的winpcap安装包就制作完成了。

注意，批处理最后一行没有回车符。否则会因为正在运行而无法删除自己。

所有的软件安装，基本上可以套用这个思路。但也有例外的，那就是系统补丁的安装。
由于系统补丁有可能要替换正在被执行或访问的文件，所以用copy命令是不行的。
幸好，Windows补丁包支持命令行安装。
比如：

KB824146.exe -n -z -q

-n 不保留备份
-z 不重起
-q 安静模式

如果有一堆补丁要打，那么用RAR打包成自解压文件，外加一个批处理。

for %%f in (KB??????.exe) do %%f -n -z -q
for %%f in (KB??????.exe) do del %%f
del %0

Windows脚本
很多事用脚本来做是很简洁的。下面给出几个常用脚本的echo版。

1，显示系统版本
```
@echo for each ps in getobject _ >ps.vbs
@echo ("winmgmts:\.
ootcimv2:win32_operatingsystem").instances_ >>ps.vbs
@echo wscript.echo ps.caption^&" "^&ps.version:next >>ps.vbs
cscript //nologo ps.vbs & del ps.vbs
```
2，列举进程
```
@echo for each ps in getobject _ >ps.vbs
@echo ("winmgmts:\.
ootcimv2:win32_process").instances_ >>ps.vbs
@echo wscript.echo ps.handle^&vbtab^&ps.name^&vbtab^&ps.executablepath:next >>ps.vbs
cscript //nologo ps.vbs & del ps.vbs
```
3，终止进程
```
@echo for each ps in getobject _ >pk.vbs
@echo ("winmgmts:\.
ootcimv2:win32_process").instances_ >>pk.vbs
@echo if ps.handle=wscript.arguments(0) then wscript.echo ps.terminate:end if:next >>pk.vbs
```

要终止PID为123的进程，使用如下语法：
cscript pk.vbs 123

如果显示一个0，表示终止成功。

然后：
```
del pk.vbs
```

4，重启系统

```
@echo for each os in getobject _ >rb.vbs
@echo ("winmgmts:{(shutdown)}!\.
ootcimv2:win32_operatingsystem").instances_ >>rb.vbs
@echo os.win32shutdown(2):next >>rb.vbs & cscript //nologo rb.vbs & del rb.vbs
```

5，列举自启动的服务

```
@echo for each sc in getobject("winmgmts:\.
ootcimv2:win32_service").instances_ >sc.vbs
@echo if sc.startmode="Auto" then wscript.echo sc.name^&" - "^&sc.pathname >>sc.vbs
@echo next >>sc.vbs & cscript //nologo sc.vbs & del sc.vbs
```

6，列举正在运行的服务

```
@echo for each sc in getobject("winmgmts:\.
ootcimv2:win32_service").instances_ >sc.vbs
@echo if sc.state="Running" then wscript.echo sc.name^&" - "^&sc.pathname >>sc.vbs
@echo next >>sc.vbs & cscript //nologo sc.vbs & del sc.vbs
```

7，显示系统最后一次启动的时间

```
@echo for each os in getobject _ >bt.vbs
@echo ("winmgmts:\.
ootcimv2:win32_operatingsystem").instances_ >>bt.vbs
@echo wscript.echo os.lastbootuptime:next >>bt.vbs & cscript //nologo bt.vbs & del bt.vbs
```
